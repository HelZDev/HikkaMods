# meta developer: —Ç–≤–æ–π_–Ω–∏–∫
from .. import loader, utils
import os

class AutoReplyMod(loader.Module):
    """–ê–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫ –¥–ª—è –Ω–æ–≤—ã—Ö –ª–∏—á–Ω—ã—Ö —á–∞—Ç–æ–≤ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Å–æ–æ–±—â–µ–Ω–∏–π –∏ –±–æ—Ç–æ–≤"""

    strings = {
        "name": "AutoReply",
        "enabled": "‚úÖ –ê–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫ –≤–∫–ª—é—á—ë–Ω",
        "disabled": "‚ùå –ê–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫ –≤—ã–∫–ª—é—á–µ–Ω",
        "reply_set": "‚úçÔ∏è –°–æ–æ–±—â–µ–Ω–∏–µ –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–æ",
        "image_set": "üñº –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–æ",
        "no_image": "‚ö†Ô∏è –ù–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è",
    }

    async def client_ready(self, client, db):
        self.db = db
        self.reply_enabled = self.db.get("AutoReply", "enabled", False)
        self.reply_text = self.db.get("AutoReply", "reply_text", "–ü—Ä–∏–≤–µ—Ç! –Ø —Å–µ–π—á–∞—Å –Ω–µ –≤ —Å–µ—Ç–∏.")
        self.image_path = self.db.get("AutoReply", "image_path", None)
        self.replied_chats = self.db.get("AutoReply", "replied_chats", {})

    async def artogglecmd(self, message):
        """–í–∫–ª—é—á–∞–µ—Ç/–≤—ã–∫–ª—é—á–∞–µ—Ç –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫"""
        self.reply_enabled = not self.reply_enabled
        self.db.set("AutoReply", "enabled", self.reply_enabled)
        await utils.answer(message, self.strings["enabled"] if self.reply_enabled else self.strings["disabled"])

    async def arsetcmd(self, message):
        """–ó–∞–¥–∞–µ—Ç –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫–∞"""
        text = utils.get_args_raw(message)
        if not text:
            return await utils.answer(message, "‚ö†Ô∏è –£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç–∞!")

        self.reply_text = text
        self.db.set("AutoReply", "reply_text", text)
        await utils.answer(message, self.strings["reply_set"])

    async def arimagecmd(self, message):
        """–ó–∞–¥–∞–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫–∞"""
        reply = await message.get_reply_message()
        if not reply or not reply.media:
            return await utils.answer(message, self.strings["no_image"])

        file_path = f"{os.getcwd()}/auto_reply.jpg"
        await reply.download_media(file_path)
        self.image_path = file_path
        self.db.set("AutoReply", "image_path", file_path)
        await utils.answer(message, self.strings["image_set"])

    async def watcher(self, message):
        """–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –Ω–æ–≤—ã–µ –ª–∏—á–Ω—ã–µ —á–∞—Ç—ã –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π"""
        if not self.reply_enabled or not message.is_private or message.out:
            return

        user = await message.get_sender()
        if user.bot:
            return  # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –±–æ—Ç–æ–≤

        user_id = message.chat_id
        if user_id in self.replied_chats:
            return  # –£–∂–µ –æ—Ç–≤–µ—Ç–∏–ª–∏ –≤ —ç—Ç–æ—Ç —á–∞—Ç

        messages = [msg async for msg in message.client.iter_messages(user_id, limit=2)]
        if len(messages) > 1:
            return  # –í —á–∞—Ç–µ —É–∂–µ –µ—Å—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º

        lang = await self.get_lang()
        reply_text = self.get_localized_reply(lang)

        if self.image_path and os.path.exists(self.image_path):
            await message.client.send_file(user_id, self.image_path, caption=reply_text)
        else:
            await message.reply(reply_text)

        self.replied_chats[user_id] = True
        self.db.set("AutoReply", "replied_chats", self.replied_chats)

    async def get_lang(self):
        """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —è–∑—ã–∫ Hikka"""
        lang = self.db.get("hikka.lang", "lang_code", "ru")  # –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ä—É—Å—Å–∫–∏–π
        return lang

    def get_localized_reply(self, lang):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç"""
        translations = {
            "ru": self.reply_text,
            "en": "Hello! I'm currently unavailable.",
            "es": "¬°Hola! No estoy disponible en este momento.",
            "fr": "Bonjour ! Je ne suis pas disponible pour le moment.",
            "de": "Hallo! Ich bin momentan nicht verf√ºgbar.",
            "zh": "‰Ω†Â•ΩÔºÅÊàëÁé∞Âú®‰∏çÂú®„ÄÇ",
        }
        return translations.get(lang, self.reply_text)
